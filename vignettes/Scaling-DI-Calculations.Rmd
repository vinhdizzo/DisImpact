---
title: "Scaling Disproportionate Impact (DI) Calculations for Interactive Visualizations"
author: "Vinh Nguyen"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
    toc: true
vignette: >
  %\VignetteIndexEntry{Scaling Disproportionate Impact (DI) Calculations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

It is often desirable to visualize student success data with the ability to disaggregate by multiple group variables to highlight equity gaps and disproportionate impact (DI) in an interactive dashboard (eg, Tableau or Power BI).  It is certainly feasible to calculate disproportionate impact on the fly in standard dashboard tools, but doing so:

1. increases development time,
2. increases the likelihood for error in calculations as the code has to be "re-written" for each dashboard, and
3. is more difficult to maintain and support, especially when transitioning projects between analysts.

A suggested workflow is to:

1. start with a student-level data set;
2. call a single function to pre-calculate success rates and disproportionate impact across all levels of disaggregation, cohorts, and scenarios;
3. export the pre-calculated data set;
4. import the pre-calculated data set to the dashboard tool of choice for visualization, where every point visualized is a row from the imported data set.

Using this workflow, one could scale up DI calculations and rapidly develop dashboards with the ability to disaggregate and highlight equity gaps / disproportionate impact for many disaggregation variables, many outcomes, and many scenarios / student populations.

The `DisImpact` package offers the `di_iterate` function that allows one to accomplish step 2 in the suggested workflow.

## Load `DisImpact` and toy data set

First, load the necessary packages.

```{r, message=FALSE, warning=FALSE}
library(DisImpact)
library(dplyr) # Ease in manipulations with data frames
```

Second, load a toy data set.

```{r}
data(student_equity) # provided from DisImpact
dim(student_equity)
# head(student_equity)
```

```{r echo=FALSE, results='asis'}
library(knitr)
kable(student_equity[1:6, ], caption='A few rows from the `student_equity` data set.')
```

To get a description of each variable, type `?student_equity` in the R console.

## Execute `di_iterate` on a data set

Let's illustrate the `di_iterate` function with some key arguments:

- `data`: a data frame of unitary (student) level or summarized data.
- `success_vars`: all outcome variables of interest.
- `group_vars`: all variables to disaggregate by (for calculating equity gaps and disproportionate impact).
- `cohort_vars` (optional): variables defining cohorts, corresponding to those in `success_vars`.
- `scenario_repeat_by_vars` (optional): variables to repeat DI calculations for across all combination of these variables.  Use only if the user is interested in performing a DI analysis for variables in `group_vars` for everyone in `data`, and separately for each combination of subpopulations specified using `scenario_repeat_by_vars`.  Each combination of these variables (eg, full time, first time college students with an ed goal of degree/transfer as one combination) would constitute an iteration / sample for which to calculate disproportionate impact for outcomes listed in `success_vars` and for the disaggregation variables listed in `group_vars`.

To see the details of these and other arguments, type `?di_iterate` in the R console.


```{r warning=FALSE}
df_di_summary <- di_iterate(data=student_equity
                          , success_vars=c('Math', 'English', 'Transfer')
                          , group_vars=c('Ethnicity', 'Gender')
                          , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
                          , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
                            )

## df_di_summary <- di_iterate(data=student_equity, success_vars=c('Math', 'English', 'Transfer'), group_vars=c('Ethnicity', 'Gender'), cohort_vars=c('Cohort', 'Cohort', 'Cohort'), scenario_repeat_by_vars=c('Ed_Goal', 'College_Status'))

## df_di_summary <- di_iterate(data=student_equity, success_vars=c('Math', 'English', 'Transfer'), group_vars=c('Ethnicity', 'Gender'), scenario_repeat_by_vars=c('Ed_Goal', 'College_Status'))

## df_di_summary_2 <- di_iterate(data=student_equity, success_vars=c('Math', 'English', 'Transfer'), group_vars=c('Ethnicity', 'Gender'), cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort'), scenario_repeat_by_vars=c('Ed_Goal', 'College_Status'), ppg_reference_groups=c('White', 'Male'), di_80_index_reference_groups=c('White', 'Male'))

## df_di_summary <- di_iterate(data=student_equity, success_vars=c('Math', 'English', 'Transfer'), group_vars=c('Ethnicity', 'Gender'), cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort'), scenario_repeat_by_vars=c('Ed_Goal', 'College_Status'), ppg_reference_groups=c('all but current'), di_80_index_reference_groups=c('White', 'Male'))
```

## Explore resulting summary data set

```{r}
dim(df_di_summary)
df_di_summary %>% head %>% as.data.frame # first few rows

```

The variables `di_indicator_ppg`, `di_indicator_prop_index`, and `di_indicator_80_index` are DI flags using the three methods.

Next, note that the scenario `'- All'` is included for all variables passed to `scenario_repeat_by_vars` by default:
```{r}
table(df_di_summary$Ed_Goal)
table(df_di_summary$College_Status)
```

Also note `di_iterate` returns non-disaggregated results by default (`'- None'` scenario):
```{r}
table(df_di_summary$disaggregation)
```

Let's inspect the rows corresponding to non-disaggregated results.

```{r results=FALSE}
# No Disaggregation
df_di_summary %>%
  filter(Ed_Goal=='- All', College_Status=='- All', disaggregation=='- None') %>%
  as.data.frame
```
```{r echo=FALSE, results='asis'}
df_di_summary %>%
  filter(Ed_Goal=='- All', College_Status=='- All', disaggregation=='- None') %>%
  as.data.frame %>% 
  kable
```

## Visualization (emulating dashboard features)

In this section, we emulate what a dashboard could visualize.

Imagine a dashboard with the following dropdown menus and option values:

- Ed Goal
  + '- All'
  + 'Degree/Transfer'
  + 'Other'
- College Status
  + '- All'
  + 'First-time college'
  + 'Other'
- Outcome:
  + 'Transfer'
  + 'Math'
  + 'English'
- Disaggregation:
  + '- None'
  + 'Ethnicity'
  + 'Gender'

Each combination of this set of dropdown menus could be visualized using a subset of rows in `df_di_summary`.

For example, let's visualize non-disaggregated results for math (the dropdown selections are described at the top of the visualization):
```{r}
# No Disaggregation
df_di_summary %>%
  filter(Ed_Goal=='- All', College_Status=='- All', success_variable=='Math', disaggregation=='- None') %>%
  as.data.frame
```
```{r include=FALSE}
run_plots <- FALSE
# run_plots <- TRUE
if (run_plots) {
  library(ggplot2)
  library(forcats)
  library(scales)

  # No Disaggregation
  df_di_summary %>%
    filter(Ed_Goal=='- All', College_Status=='- All', success_variable=='Math', disaggregation=='- None') %>%
    select(cohort, group, n, pct, di_indicator_ppg, di_indicator_prop_index, di_indicator_80_index) %>%
    mutate(group=factor(group) %>% fct_reorder(desc(pct))) %>% 
    ggplot(data=., mapping=aes(x=factor(cohort), y=pct, group=group, color=group)) +
    geom_point() +
    geom_line() +
    xlab('Cohort') +
    ylab('Rate') +
    theme_bw() +
    scale_color_manual(values=c('#1b9e77'), name='Group') +
                                        # labs(size='Disproportionate Impact') +
  scale_y_continuous(labels = percent, limits=c(0, 1)) +
    ggtitle('Dashboard drop-down selections:', subtitle=paste0("Ed Goal = '- All' | College Status = '- All' | Outcome = 'Math' | Disaggregation = '- None'"))
  ggsave('Dashboard_1.png', height=5, width=9)
}
```
![Dashboard Viz 1: Non-disaggregated results.](./Dashboard_1.png){width=100%}

In this dashboard, one could choose to disaggregate by ethnicity and highlight disproportionate impact (for simplicity, let's use the percentage point gap method, or the `di_indicator_ppg` flag in subsequent visualizations):
```{r}
# Disaggregation: Ethnicity
df_di_summary %>%
  filter(Ed_Goal=='- All', College_Status=='- All', success_variable=='Math', disaggregation=='Ethnicity') %>%
  select(cohort, group, n, pct, di_indicator_ppg, di_indicator_prop_index, di_indicator_80_index) %>%
  as.data.frame
```
```{r include=FALSE}
if (run_plots) {
  # Disaggregation: Ethnicity
  df_di_summary %>%
    filter(Ed_Goal=='- All', College_Status=='- All', success_variable=='Math', disaggregation=='Ethnicity') %>%
    select(cohort, group, n, pct, di_indicator_ppg, di_indicator_prop_index, di_indicator_80_index) %>%
    mutate(group=factor(group) %>% fct_reorder(desc(pct))) %>% 
    ggplot(data=., mapping=aes(x=factor(cohort), y=pct, group=group, color=group)) +
    geom_point(aes(size=factor(di_indicator_ppg, levels=c(0, 1), labels=c('Not DI', 'DI')))) +
    geom_line() +
    xlab('Cohort') +
    ylab('Rate') +
    theme_bw() +
    scale_color_manual(values=c('#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02'), name='Ethnicity') +
    labs(size='Disproportionate Impact') +
    scale_y_continuous(labels = percent, limits=c(0, 1)) +
    ggtitle('Dashboard drop-down selections:', subtitle=paste0("Ed Goal = '- All' | College Status = '- All' | Outcome = 'Math' | Disaggregation = 'Ethnicity'"))
  ggsave('Dashboard_2.png', height=5, width=9)
}
```
![Dashboard Viz 2: Disaggregated by ethnicity.](./Dashboard_2.png){width=100%}

In a dashboard, the user might be interested in focusing on degree/transfer students.  We emulate this by filtering on `Ed_Goal=='Deg/Transer'`:
```{r}
# Disaggregation: Ethnicity; Deg/Transfer
df_di_summary %>%
  filter(Ed_Goal=='Deg/Transfer', College_Status=='- All', success_variable=='Math', disaggregation=='Ethnicity') %>%
  select(cohort, group, n, pct, di_indicator_ppg, di_indicator_prop_index, di_indicator_80_index) %>%
  as.data.frame
```
```{r include=FALSE}
if (run_plots) {
  # Disaggregation: Ethnicity; Deg/Transfer
  df_di_summary %>%
    filter(Ed_Goal=='Deg/Transfer', College_Status=='- All', success_variable=='Math', disaggregation=='Ethnicity') %>%
    select(cohort, group, n, pct, di_indicator_ppg, di_indicator_prop_index, di_indicator_80_index) %>%
    mutate(group=factor(group) %>% fct_reorder(desc(pct))) %>% 
    ggplot(data=., mapping=aes(x=factor(cohort), y=pct, group=group, color=group)) +
    geom_point(aes(size=factor(di_indicator_ppg, levels=c(0, 1), labels=c('Not DI', 'DI')))) +
    geom_line() +
    xlab('Cohort') +
    ylab('Rate') +
    theme_bw() +
    scale_color_manual(values=c('#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02'), name='Ethnicity') +
    labs(size='Disproportionate Impact') +
    scale_y_continuous(labels = percent, limits=c(0, 1)) +
    ggtitle('Dashboard drop-down selections:', subtitle=paste0("Ed Goal = 'Deg/Transfer' | College Status = '- All' | Outcome = 'Math' | Disaggregation = 'Ethnicity'"))
  ggsave('Dashboard_3.png', height=5, width=9)
}
```
![Dashboard Viz 3: Focus on degree/transfer students.](./Dashboard_3.png){width=100%}

In a dashboard, the user could switch the outcome to English and disaggregate by Gender:
```{r}
# Disaggregation: Gender; Deg/Transfer; English
df_di_summary %>%
  filter(Ed_Goal=='Deg/Transfer', College_Status=='- All', success_variable=='English', disaggregation=='Gender') %>%
  as.data.frame
```
```{r include=FALSE}
if (run_plots) {
  # Disaggregation: Gender; Deg/Transfer; English
  df_di_summary %>%
    filter(Ed_Goal=='Deg/Transfer', College_Status=='- All', success_variable=='English', disaggregation=='Gender') %>%
    select(cohort, group, n, pct, di_indicator_ppg, di_indicator_prop_index, di_indicator_80_index) %>%
    mutate(group=factor(group) %>% fct_reorder(desc(pct))) %>% 
    ggplot(data=., mapping=aes(x=factor(cohort), y=pct, group=group, color=group)) +
    geom_point(aes(size=factor(di_indicator_ppg, levels=c(0, 1), labels=c('Not DI', 'DI')))) +
    geom_line() +
    xlab('Cohort') +
    ylab('Rate') +
    theme_bw() +
    scale_color_manual(values=c('#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02'), name='Gender') +
    labs(size='Disproportionate Impact') +
    scale_y_continuous(labels = percent, limits=c(0, 1)) +
    ggtitle('Dashboard drop-down selections:', subtitle=paste0("Ed Goal = 'Deg/Transfer' | College Status = '- All' | Outcome = 'English' | Disaggregation = 'Gender'"))
  ggsave('Dashboard_4.png', height=5, width=9)
}
```
![Dashboard Viz 4: switch outcome to English and disaggregate by Gender.](./Dashboard_4.png){width=100%}

## What is the difference between `group_vars` and `scenario_repeat_by_vars`?

For different classification variables, (eg, age group, full time status, and education goal), the user might be confused as to whether to pass these into the `group_vars` argument or the `scenario_repeat_by_vars` argument.  The answer is it depends on what the user wants to analyze.  If we think of a single student population of interest (eg, the data set being passed to `di_iterate` such as all students enrolled at the institution), then the user should pass into `group_vars` all variables that they are *interested in disaggregating on and performing a DI analysis* (eg, are there disparity among ethnic student groups?  First generation students?).  The `group_vars` argument is required.

On the other hand, the `scenario_repeat_by_vars` argument is optional, and when not specified, the DI analysis is performed on all outcomes specified in `success_vars` and all disaggregation variables specified in `group_vars`, using all students passed to `data` as a single population.  The user should only pass variables into `scenario_repeat_by_vars` if they want to split the student population into multiple subpopulations to perform DI analysis on.  For example, if ethnicity, first generation status, and age group and were specified in `group_vars`, then the user is trying to answer the following questions:

1. Is there disparity between different ethnic student groups?
2. Is there disparity between first generation students vs. non-first generation students?
3. Is there disparity between students of different age groups?

If on the other hand, the user passes ethnicity and first generation status to `group_vars`, and age group to `scenario_repeat_by_vars`, then the user is trying to answer the following questions:

1. Is there disparity between different ethnic student groups?
   a. Among all students defined by `data`?
   b. Among different subpopulations defined by age group?  (eg, among each of these groups: 18-21, 22-25, 26-35, 35-50, 51+)
2. Is there disparity between first generation students vs. non-first generation students?
   a. Among all students defined by `data`?
   b. Among different subpopulations defined by age group?  (eg, among each of these groups: 18-21, 22-25, 26-35, 35-50, 51+)

## Understanding the default parameters in `di_iterate`, and overriding them

The function `di_iterate` has been designed to be highly flexible through the use of function arguments / parameters, with many defaults:
```{r}
args(di_iterate)
```

In this section, we illustrate how each argument could be used.  Type `?di_iterate` to read the description of each.

### Passing a summarized data set to `data` and using `weight_var`

Instead of passing in a student level data set, the user could also pass in a summarized data set, which saves space on your disk drive or in memory when imported into R.  When passing a summarized data set, the user should also specify `weight_var` to indicate the group size of each row.  Let's illustrate with an example:

```{r}
dim(student_equity)

## Example summarized data set
student_equity_summ <- student_equity %>%
  group_by(Ethnicity, Gender, Cohort, Cohort_Math, Cohort_English, Ed_Goal, College_Status) %>%
  summarize(N=n() %>% as.numeric # not needed, for all.equal()
            , Math=sum(Math, na.rm=TRUE)
            , English=sum(English, na.rm=TRUE)
            , Transfer=sum(Transfer, na.rm=TRUE)
            ) %>%
  ungroup

dim(student_equity_summ) # same number of columns, less number of rows

student_equity_summ %>% head %>% as.data.frame # first few rows

## Run on summarized data set
df_di_summary_2 <- di_iterate(data=student_equity_summ
                          , success_vars=c('Math', 'English', 'Transfer')
                          , group_vars=c('Ethnicity', 'Gender')
                          , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
                          , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
                          , weight_var='N' # SET THIS
                            )
dim(df_di_summary)  ## original results
dim(df_di_summary_2) # more rows?  because of NA cohort from Cohort_English and Cohort_Math
dim(df_di_summary_2 %>% filter(!is.na(cohort)))

## ## if user wants to see the extra rows
## extra_rows <- df_di_summary_2 %>%
##   anti_join(df_di_summary %>% select(Ed_Goal, College_Status, success_variable, cohort_variable, cohort, disaggregation, group))
## difference %>% head %>% as.data.frame  

all.equal(df_di_summary
        , df_di_summary_2 %>% filter(!is.na(cohort))
          ) # returned results are the same

```

### Suppress non-disaggregated results using `include_non_disagg_results`

By default, the non-disaggregated results are also returned.  If the user wants to suppress this, they could set `include_non_disagg_results=FALSE`:

```{r}
df_di_summary_2 <- di_iterate(data=student_equity
                          , success_vars=c('Math', 'English', 'Transfer')
                          , group_vars=c('Ethnicity', 'Gender')
                          , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
                          , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
                          , include_non_disagg_results=FALSE ## SET THIS
                            )
dim(df_di_summary)
dim(df_di_summary_2) ## less rows because no longer have disaggregated results
table(df_di_summary$disaggregation)
table(df_di_summary_2$disaggregation) # No more '- None'
```

### PPG reference groups and other parameters

For the percentage point gap (PPG) method, `di_iterate` defaults to using the overall success rate as the reference for comparison (`ppg_reference_groups='overall'`).  The user could set `ppg_reference_groups='hpg'` for using the highest performing group as the comparison group, or `ppg_reference_groups='all but current'` for using the combined success rate of all other groups excluding the group of interest (eg, if studying Hispanic students, then the reference group would be all non-Hispanic students).  The latter is sometimes referred to as "PPG minus 1."  The user could also specify specific groups as reference:

```{r}
# Highest performing group as reference
df_di_summary_2 <- di_iterate(data=student_equity
                            , success_vars=c('Math', 'English', 'Transfer')
                            , group_vars=c('Ethnicity', 'Gender')
                            , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
                            , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
                            , ppg_reference_groups='hpg' ## SET THIS
                              )

# Reference: all other groups except group of interest (PPG minus 1)
df_di_summary_2 <- di_iterate(data=student_equity
                            , success_vars=c('Math', 'English', 'Transfer')
                            , group_vars=c('Ethnicity', 'Gender')
                            , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
                            , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
                            , ppg_reference_groups='all but current' ## SET THIS
                              )

# Reference: custom groups
df_di_summary_2 <- di_iterate(data=student_equity
                            , success_vars=c('Math', 'English', 'Transfer')
                            , group_vars=c('Ethnicity', 'Gender')
                            , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
                            , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
                            , ppg_reference_groups=c('White', 'Male') ## corresponds to each variable in group_vars
                              )
```

The following arguments apply to the PPG: `min_moe`, `use_prop_in_moe`, `prop_sub_0`, `prop_sub_1`, and `use_prop_in_moe`.  See `?di_ppg` for more details.

### Proportionality index DI threshold

For the proportionality index (PI) method, DI is determined using `di_prop_index_cutoff=0.8` by default.  This could be changed using the `di_prop_index_cutoff` argument.

```{r}
df_di_summary_2 <- di_iterate(data=student_equity
                            , success_vars=c('Math', 'English', 'Transfer')
                            , group_vars=c('Ethnicity', 'Gender')
                            , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
                            , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
                            , di_prop_index_cutoff=0.9 # Easier to declare DI using PI
                              )
```

### 80% index reference groups and DI threshold

For the 80% index method, the highest performing group is used as reference by default (`di_80_index_reference_groups=NA`).  Similar to the PPG, the user could specify custom reference groups.

```{r}
# Custom reference groups
df_di_summary_2 <- di_iterate(data=student_equity
                            , success_vars=c('Math', 'English', 'Transfer')
                            , group_vars=c('Ethnicity', 'Gender')
                            , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
                            , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
                            , di_80_index_reference_groups=c('White', 'Male') ## corresponds to each variable in group_vars
                              )
```

The 80% index uses 80% as the default threshold for declaring DI.  The user could alter this with the `di_80_index_cutoff` argument.

```{r}
df_di_summary_2 <- di_iterate(data=student_equity
                            , success_vars=c('Math', 'English', 'Transfer')
                            , group_vars=c('Ethnicity', 'Gender')
                            , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
                            , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
                            , di_80_index_cutoff=0.5 # Harder to declare DI using 80% index
                              )
```

## Multiple PPG or DI parameter scenarios in results

In a single call of `di_iterate`, the results of all three DI methods are returned in one run.  If the user is interested in doing DI calculations using various scenarios of the same method (eg, using the overall rate as reference for PPG, and using a pre-specified list of reference rates), then it is recommended that the user execute `di_iterate` multiple times and combining the results (stacking).  If the user chooses to do this, then it is a good idea to set `include_non_disagg_results=FALSE` in subsequent `di_iterate` runs to not duplicate rows of non-disaggregated results.

```{r}
# Multiple group variables and different reference groups
df_di_summary_long <- bind_rows(
  di_iterate(data=student_equity
           , success_vars=c('Math', 'English', 'Transfer')
           , group_vars=c('Ethnicity', 'Gender')
           , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
           , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
             )
  , di_iterate(data=student_equity
           , success_vars=c('Math', 'English', 'Transfer')
           , group_vars=c('Ethnicity', 'Gender')
           , cohort_vars=c('Cohort_Math', 'Cohort_English', 'Cohort')
           , scenario_repeat_by_vars=c('Ed_Goal', 'College_Status')
           , ppg_reference_groups=c('White', 'Male') ## corresponds to each variable in group_vars
           , include_non_disagg_results = FALSE # Already have non-disaggregated results in the first run
             )
)

dim(df_di_summary_long)
```

## FERPA block/suppression

Since `di_iterate` disaggregates on many variables and subpopulations, it is not uncommon the returned results contain rows summarizing small samples.  As is common in education research, care should be taken to not unintentionally disclose the educational outcomes of students (results linked to particular students, ie, FERPA regulation).  The user might want to filter out rows with small samples (eg, `n < 10`):
```{r}
## df_di_summary %>%
##   mutate(FERPA_Block=ifelse(n < 10, 1, 0)) %>%
##   filter(FERPA_Block == 0)
```
